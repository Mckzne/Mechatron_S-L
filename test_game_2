import json
import random
import time
import os
import paho.mqtt.client as mqtt

# ---------- Configuration ----------
BROKER = "192.168.1.28"
MQTT_PORT = 1883
STATE_FILE = "game_state.json"

TILE_MAPPING = {
    'esp/1/in':  {'tiles': [1, 2, 19, 20], 'pins': [13, 12, 27, 14]},
    'esp/2/in':  {'tiles': [3, 4, 17, 18], 'pins': [13, 12, 27, 14]},
    'esp/3/in':  {'tiles': [5, 6, 15, 16], 'pins': [13, 12, 27, 14]},
    'esp/4/in':  {'tiles': [7, 8, 13, 14], 'pins': [13, 12, 27, 14]},
    'esp/5/in':  {'tiles': [9, 10, 11, 12], 'pins': [12, 13, 14, 27]},
    'esp/10/in':  {'tiles': [29, 30, 31, 32], 'pins': [13, 12, 27, 14]},
    'esp/9/in':  {'tiles': [27, 28, 33, 34], 'pins': [13, 12, 27, 14]},
    'esp/8/in':  {'tiles': [25, 26, 35, 36], 'pins': [13, 12, 27, 14]},
    'esp/7/in':  {'tiles': [23, 24, 37, 38], 'pins': [13, 12, 27, 14]},
    'esp/6/in': {'tiles': [21, 22, 39, 40], 'pins': [13, 12, 27, 14]},
    'esp/11/in': {'tiles': [41, 42, 59, 60], 'pins': [13, 12, 27, 14]},
    'esp/12/in': {'tiles': [43, 44, 57, 58], 'pins': [13, 12, 27, 14]},
    'esp/13/in': {'tiles': [45, 46, 55, 56], 'pins': [13, 12, 27, 14]},
    'esp/14/in': {'tiles': [47, 48, 53, 54], 'pins': [13, 12, 27, 14]},
    'esp/15/in': {'tiles': [49, 50, 51, 52], 'pins': [13, 12, 27, 14]},
    'esp/16/in': {'tiles': [69, 70, 71, 72], 'pins': [13, 12, 27, 14]},
    'esp/17/in': {'tiles': [67, 68, 73, 74], 'pins': [13, 12, 27, 14]},
    'esp/18/in': {'tiles': [65, 66, 75, 76], 'pins': [13, 12, 27, 14]},
    'esp/19/in': {'tiles': [63, 64, 77, 78], 'pins': [13, 12, 27, 14]},
    'esp/20/in': {'tiles': [61, 62, 79, 80], 'pins': [13, 12, 27, 14]},
    'esp/21/in': {'tiles': [89, 90, 91, 92], 'pins': [13, 12, 27, 14]},
    'esp/22/in': {'tiles': [87, 88, 93, 94], 'pins': [13, 12, 27, 14]},
    'esp/23/in': {'tiles': [85, 86, 95, 96], 'pins': [13, 12, 27, 14]},
    'esp/24/in': {'tiles': [83, 84, 97, 98], 'pins': [13, 12, 27, 14]},
    'esp/25/in': {'tiles': [81, 82, 99, 100], 'pins': [13, 12, 27, 14]}
}

TEAMS = {
    "Team1": {"color": "#FF4500"},  # Orange Red
    "Team2": {"color": "#00CED1"},  # Dark Turquoise
    "Team3": {"color": "#FFD700"},  # Gold
    "Team4": {"color": "#32CD32"},  # Lime Green
    "Team5": {"color": "#8A2BE2"},  # Blue Violet
    "Team6": {"color": "#DC143C"}   # Crimson Red
}

MAX_TILES = 100

client = mqtt.Client("master_pi", protocol=mqtt.MQTTv311)
client.connect(BROKER, MQTT_PORT, 60)
client.loop_start()

# ---------- Utility Functions ----------
def publish(topic, payload):
    client.publish(topic, json.dumps(payload))

def log(msg):
    print(f"[{time.strftime('%H:%M:%S')}] {msg}")

def save_state(game_state):
    with open(STATE_FILE, "w") as f:
        json.dump(game_state, f)

def load_state():
    if os.path.exists(STATE_FILE):
        with open(STATE_FILE, "r") as f:
            return json.load(f)
    return None

def all_leds_off():
    for topic, mapping in TILE_MAPPING.items():
        payload = {"tile": None, "state": "off", "color": "#000000"}
        publish(topic, payload)
    log("All LEDs turned off")

def turn_tile_on(tile, color):
    for topic, mapping in TILE_MAPPING.items():
        if tile in mapping["tiles"]:
            idx = mapping["tiles"].index(tile)
            pin = mapping["pins"][idx]
            payload = {"tile": tile, "state": "on", "color": color}
            print(f"Publishing to {topic} tile {tile} on pin {pin} color {color}")  # Debug log
            publish(topic, payload)
            time.sleep(0.05)  # Small delay between publishes for stability

def roll_dice():
    return random.randint(1, 6)

# ---------- Lighting Animation ----------
def sequential_all_tile_lighting():
    log("Lighting tiles one by one...")
    all_leds_off()
    for tile in range(1, MAX_TILES + 1):
        turn_tile_on(tile, "#FFD700")  # Gold color instead of white
        time.sleep(0.07)  # Slight delay between each tile lighting
    log("All 100 tiles are ON.")

# ---------- Dice Animation ----------
def animate_move(team, start, end):
    team_color = TEAMS[team]["color"]
    if end > start:
        path = list(range(start + 1, end + 1))
    else:
        path = list(range(start - 1, end - 1, -1))

    # Light up each tile from start to end, keeping previous ones ON
    for tile in path:
        turn_tile_on(tile, team_color)
        time.sleep(0.5)

    time.sleep(5)

    # Turn OFF all except final position
    for tile in path[:-1]:
        turn_tile_on(tile, "#000000")
    turn_tile_on(path[-1], team_color)

# ---------- Main Control Loop ----------
def main_loop():
    while True:
        print("\nChoose Action: ")
        print("1. Run All-Tile Lighting Animation")
        print("2. Start Game")
        action = input("Enter 1 or 2: ").strip()

        if action == "1":
            all_leds_off()
            sequential_all_tile_lighting()
            # After animation, ask whether to play again or rerun lighting
            again = input("All tiles lit. Run lighting again or start game? (lighting/game): ").strip().lower()
            if again == "lighting":
                continue
            elif again != "game":
                print("Invalid input, starting over.")
                continue

        if action == "2" or (action == "1" and again == "game"):
            all_leds_off()

            print("\nDo you want to load previous state or start fresh?")
            choice = input("Enter 'load' to continue or 'reset' to start from 0: ").strip().lower()
            if choice == "load":
                game_state = load_state()
                if not game_state:
                    print("No previous state found. Starting new game.")
                    game_state = {"positions": {team: 0 for team in TEAMS}}
                else:
                    for team, pos in game_state["positions"].items():
                        if pos > 0:
                            turn_tile_on(pos, TEAMS[team]["color"])
            else:
                game_state = {"positions": {team: 0 for team in TEAMS}}

            all_leds_off()

            while True:
                print("\nCurrent Positions:")
                for team, pos in game_state["positions"].items():
                    print(f"{team}: {pos}")
                    if pos > 0:
                        turn_tile_on(pos, TEAMS[team]["color"])

                first_team = input("\nWhich team pressed the buzzer first? (Team1-Team6): ").strip()
                if first_team not in TEAMS:
                    print("Invalid team name. Try again.")
                    continue

                choice = input("Choose: another round or roll dice? (round/roll): ").strip().lower()
                if choice == "round":
                    other_teams = [t for t in TEAMS if t != first_team]
                    next_team = input(f"{first_team} can't answer. Which team wants to answer? (Choose one of {other_teams}): ").strip()
                    if next_team not in other_teams:
                        print("Invalid team. Round reset.")
                        continue
                    result = input("Is the answer correct or wrong? (correct/wrong): ").strip().lower()
                    if result == "wrong":
                        print("Wrong answer, round resetting...")
                        continue
                    else:
                        steps = roll_dice()
                        old_tile = game_state['positions'][next_team]
                        new_tile = min(old_tile + steps, MAX_TILES)
                        animate_move(next_team, old_tile, new_tile)
                        game_state['positions'][next_team] = new_tile
                        save_state(game_state)
                        continue

                elif choice == "roll":
                    steps = roll_dice()
                    old_tile = game_state['positions'][first_team]
                    new_tile = min(old_tile + steps, MAX_TILES)
                    animate_move(first_team, old_tile, new_tile)
                    game_state['positions'][first_team] = new_tile
                    save_state(game_state)
                    continue
                else:
                    print("Invalid input, try again.")

if __name__ == "__main__":
    main_loop()
