import json
import random
import time
import os
import paho.mqtt.client as mqtt

# ---------- Configuration ----------
BROKER = "192.168.1.28"
MQTT_PORT = 1883
STATE_FILE = "game_state.json"

TILE_MAPPING = {
    'esp/1/in':  {'tiles': [1, 2, 19, 20], 'pins': [13, 12, 27, 14]},
    'esp/2/in':  {'tiles': [3, 4, 17, 18], 'pins': [13, 12, 27, 14]},
    'esp/3/in':  {'tiles': [5, 6, 15, 16], 'pins': [13, 12, 27, 14]},
    'esp/4/in':  {'tiles': [7, 8, 13, 14], 'pins': [13, 12, 27, 14]},
    'esp/5/in':  {'tiles': [9, 10, 11, 12], 'pins': [12, 13, 14, 27]},
    'esp/10/in':  {'tiles': [29, 30, 31, 32], 'pins': [13, 12, 27, 14]},
    'esp/9/in':  {'tiles': [27, 28, 33, 34], 'pins': [13, 12, 27, 14]},
    'esp/8/in':  {'tiles': [25, 26, 35, 36], 'pins': [13, 12, 27, 14]},
    'esp/7/in':  {'tiles': [23, 24, 37, 38], 'pins': [13, 12, 27, 14]},
    'esp/6/in': {'tiles': [21, 22, 39, 40], 'pins': [13, 12, 27, 14]},
    'esp/11/in': {'tiles': [41, 42, 59, 60], 'pins': [13, 12, 27, 14]},
    'esp/12/in': {'tiles': [43, 44, 57, 58], 'pins': [13, 12, 27, 14]},
    'esp/13/in': {'tiles': [45, 46, 55, 56], 'pins': [13, 12, 27, 14]},
    'esp/14/in': {'tiles': [47, 48, 53, 54], 'pins': [13, 12, 27, 14]},
    'esp/15/in': {'tiles': [49, 50, 51, 52], 'pins': [13, 12, 27, 14]},
    'esp/16/in': {'tiles': [69, 70, 71, 72], 'pins': [13, 12, 27, 14]},
    'esp/17/in': {'tiles': [67, 68, 73, 74], 'pins': [13, 12, 27, 14]},
    'esp/18/in': {'tiles': [65, 66, 75, 76], 'pins': [13, 12, 27, 14]},
    'esp/19/in': {'tiles': [63, 64, 77, 78], 'pins': [13, 12, 27, 14]},
    'esp/20/in': {'tiles': [61, 62, 79, 80], 'pins': [13, 12, 27, 14]},
    'esp/21/in': {'tiles': [89, 90, 91, 92], 'pins': [13, 12, 27, 14]},
    'esp/22/in': {'tiles': [87, 88, 93, 94], 'pins': [13, 12, 27, 14]},
    'esp/23/in': {'tiles': [85, 86, 95, 96], 'pins': [13, 12, 27, 14]},
    'esp/24/in': {'tiles': [83, 84, 97, 98], 'pins': [13, 12, 27, 14]},
    'esp/25/in': {'tiles': [81, 82, 99, 100], 'pins': [13, 12, 27, 14]}
}

TEAMS = {
    "Team1": {"color": "#FF4500"},  # Orange Red
    "Team2": {"color": "#00CED1"},  # Dark Turquoise
    "Team3": {"color": "#FFD700"},  # Gold
    "Team4": {"color": "#32CD32"},  # Lime Green
    "Team5": {"color": "#8A2BE2"},  # Blue Violet
    "Team6": {"color": "#DC143C"}   # Crimson Red
}

MAX_TILES = 100

client = mqtt.Client(client_id="master_pi", protocol=mqtt.MQTTv311)
client.connect(BROKER, MQTT_PORT, 60)
client.loop_start()

# ---------- Utility Functions ----------
def publish(topic, payload):
    client.publish(topic, json.dumps(payload))

def log(msg):
    print(f"[{time.strftime('%H:%M:%S')}] {msg}")

def save_state(game_state):
    with open(STATE_FILE, "w") as f:
        json.dump(game_state, f)

def load_state():
    if os.path.exists(STATE_FILE):
        with open(STATE_FILE, "r") as f:
            return json.load(f)
    return None

def all_leds_off():
    for topic, mapping in TILE_MAPPING.items():
        for pin in mapping["pins"]:
            payload = {"tile": None, "state": "off", "color": "#000000"}
            publish(topic, payload)

def turn_tile_on(tile, color):
    """Turn on a tile with a given color."""
    for topic, mapping in TILE_MAPPING.items():
        if tile in mapping["tiles"]:
            idx = mapping["tiles"].index(tile)
            pin = mapping["pins"][idx]
            payload = {"tile": tile, "state": "on", "color": color}
            publish(topic, payload)

def roll_dice():
    return random.randint(1, 6)

# ---------- Tile Lighting Animation ----------
def lighting_animation():
    log("Starting all-tile lighting. All tiles will light up one by one and remain on.")
    all_leds_off()
    for tile in range(1, MAX_TILES + 1):
        turn_tile_on(tile, "#FFFFFF")
        time.sleep(0.05)
    log("All tiles are ON.")
    time.sleep(3)

# ---------- Dice Move Animation ----------
def animate_move(team, start, end):
    team_color = TEAMS[team]["color"]
    if end > start:
        path = list(range(start + 1, end + 1))
    else:
        path = list(range(start - 1, end - 1, -1))
    if not path:
        return

    # Light up all tiles along move path one by one, all remain on
    for tile in path:
        turn_tile_on(tile, team_color)
        time.sleep(0.5)

    # All path tiles stay ON for 5 seconds
    time.sleep(5)

    # Turn off all path tiles except final one
    for tile in path[:-1]:
        turn_tile_on(tile, "#000000")
    turn_tile_on(path[-1], team_color)

# ---------- Main Game Loop ----------
def main_loop():
    while True:
        # Ask for mode: lighting or game
        print("\nChoose a mode:\n1. Tile lighting animation (lighting)\n2. Game mode (game)")
        mode_choice = input("Enter 'lighting' or 'game': ").strip().lower()
        
        all_leds_off()

        if mode_choice == "lighting":
            lighting_animation()
            # After lighting, ask again
            cont_choice = input("\nLighting done. Do you want to run lighting again or start game? (lighting/game): ").strip().lower()
            if cont_choice == "lighting":
                continue
            elif cont_choice == "game":
                mode_choice = "game"
            else:
                print("Invalid input. Returning to menu.")
                continue
        
        if mode_choice == "game":
            # Ask whether to start from previous state or reset
            print("\nStart game from previous saved state or reset and start fresh?")
            state_choice = input("Type 'previous' or 'reset': ").strip().lower()
            game_state = None
            if state_choice == "previous":
                game_state = load_state()
                if not game_state:
                    print("No previous state found. Starting fresh.")
                    game_state = {"positions": {team: 0 for team in TEAMS}}
            else:
                game_state = {"positions": {team: 0 for team in TEAMS}}

            all_leds_off()
            # Light up initial positions
            for team, pos in game_state["positions"].items():
                if pos > 0:
                    turn_tile_on(pos, TEAMS[team]["color"])

            while True:
                print("\nCurrent Positions:")
                for team, pos in game_state["positions"].items():
                    print(f"{team}: {pos}")
                    if pos > 0:
                        turn_tile_on(pos, TEAMS[team]["color"])

                first_team = input("\nWhich team pressed the buzzer first? (Team1â€“Team6): ").strip()
                if first_team not in TEAMS:
                    print("Invalid team name. Try again.")
                    continue

                choice = input("Choose: another round or roll dice? (round/roll): ").strip().lower()

                if choice == "round":
                    other_teams = [t for t in TEAMS if t != first_team]
                    next_team = input(f"{first_team} can't answer. Which team wants to answer? (Choose one of {other_teams}): ").strip()
                    if next_team not in other_teams:
                        print("Invalid team. Round reset.")
                        continue
                    result = input("Is the answer correct or wrong? (correct/wrong): ").strip().lower()
                    if result == "wrong":
                        print("Wrong answer, round resetting...")
                        continue
                    else:
                        steps = roll_dice()
                        old_tile = game_state['positions'][next_team]
                        new_tile = min(old_tile + steps, MAX_TILES)
                        animate_move(next_team, old_tile, new_tile)
                        game_state['positions'][next_team] = new_tile
                        save_state(game_state)
                        continue

                elif choice == "roll":
                    steps = roll_dice()
                    old_tile = game_state['positions'][first_team]
                    new_tile = min(old_tile + steps, MAX_TILES)
                    animate_move(first_team, old_tile, new_tile)
                    game_state['positions'][first_team] = new_tile
                    save_state(game_state)
                else:
                    print("Invalid input, try again.")
            # end of game while loop

if __name__ == "__main__":
    main_loop()
